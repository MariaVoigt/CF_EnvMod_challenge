---
title: 'Climate Farmer Coding Challenge'
author: "Maria Voigt"
date: '`r format(Sys.time(), "%d\\. %B %Y")`'
output:
  html_document:
    css: "./aux/report_tab.css"
    number_sections: yes
    toc: TRUE
    toc_float:
      collapsed: FALSE
---


<div class="vspace_big"></div>
<img src="./aux/cropped_climate_farmers.png" alt="Red Line" class="img_center" width= 10% height=5%></img>
<div class="vspace_small"></div>
<p style="font-size:2em; font-weight:100; text-align: center">Coding challenge for Climate Farmers</p>
<div class="vspace_small"></div>


```{r global-options, include=FALSE}
# load packages ---------------------------------------------------------

# basic
library(tidyverse)   # Collection of R packages designed for data science
library(rlang)       # A toolbox for working with base type (e.g. environments)
library(htmltools)   # Tools for HTML generation and output
library(here)        # Facilitates easy file path management within R projects
# spatial operations
library(sf)           # Comprehensive toolset for handling spatial data
library(terra)        # Efficient manipulation & analysis of raster data
library(tidyterra)    # Extends 'terra' for tidyverse-friendly raster operations
library(ncdf4)        # Reading/writing data in netCDF format
options("sp_evolution_status" = 2) 
library(exactextractr) # extraction of raster values based on geometries and resampling
# plotting
library(gridExtra)    # Functions for arranging of plots 
library(grid)         # Tools for grid-based object creation and manipulation
library(gtable)      # Tools for manipulating graphical object tables in R's grid system
library(lemon)        # Tools for visualization and manipulation of multi-way data arrays

# set knitr options ------------------------------------------------------------
options(scipen = 999)

# Theme for ggplot  ---------------------------------------------------------

theme_simple <- function() {
theme_bw()+
theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.background = element_blank(), 
  axis.text.y = element_text(size = 12),
  axis.text.x=element_text(size = 12, angle = 90, hjust=0.5,vjust=0.2),
  axis.title=element_text(size = 18, face = "bold"),
  strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
  strip.text = element_text(size = 16, face="bold"))
}



# set path to script ------------------------------------------------------------
here::i_am("src/markdown/Coding_challenge.Rmd")


# source functions to visualise landcover
source(here("src/functions/0_visualise_landcover_classes.R"))
```


# Region Selection and Data Aqcuisition
## Region selection and basemap preparation 


I decided to work with Portugal, because it includes various types of landcover,
and has variability in soil organic carbon and climate. I imported the country shape from the gadm database [GADM database](https://gadm.org/download_country.html).
As I want to work with mainland Portugal, I excluded Madeira and the Azores.

I decided to work with Portugal, because it includes various types of landcover,
and has variability in soil organic carbon and climate. I imported the country shape from the gadm database [GADM database](https://gadm.org/download_country.html).
As I want to work with mainland Portugal, I excluded Madeira and the Azores.

```{r load_data_prep, include = FALSE}
# Load results for data prep ----------------------------------------------------
data_prep_env<- env()
source(here("src/analysis/1_read_and_prep_data.R"), local = data_prep_env, encoding = "UTF-8")

```

```{r basemap, fig.asp = 0.8, fig.width = 10, echo = FALSE, fig.cap="Shape of mainland Portugal used to restrict the analysis of soil, landcover and climate data."}
ggplot() + 
  geom_sf(data=sf::st_as_sf(data_prep_env$pt_mainland), color = "black", 
          fill = "grey")+
  theme_simple()

```

## Data Aqcuisition {.tabset}
<div class="vspace_mid"></div>

I downloaded the following datasets for the analysis:
<div class="p">
<ol>
  <li>
    <strong>Climate (years 2020-2022):</strong>
    <ul>
      <li>
        <em>Temperature (unit: Kelvin):</em><br>
        Air temperature 2 meters above land or water surfaces.
      </li>
      <li>
        <em>Evapotranspiration (unit: Meters):</em><br>
        Accumulated amount of water that has evaporated from the Earth's surface, including a simplified representation of transpiration from vegetation.
      </li>
      <li>
        <em>Precipitation (unit: Meters):</em><br>
        Accumulated liquid and frozen water (rain, snow) falling to Earth's surface, excluding fog, dew, and evaporated precipitation. It is the depth the water would have if it were spread evenly over the grid box.
      </li>
    </ul>
  </li>
  <li>
    <strong>Landcover (year 2020):</strong>
    <ul>
      <li>
        <em>Global gridded land cover classification:</em><br>
        Land cover class per pixel, according to a legend of 22 classes, defined using the Land Cover Classification System developed by the United Nations Food and Agriculture Organization. 
      </li>
    </ul>
  </li>
  <li>
    <strong>Soil organic carbon (SOC):</strong>
    <ul>
      <li>
        <em>Soil organic carbon (unit: t/ha):</em><br>
        Soil organic carbon content in 0-30 cm depth.
      </li>
    </ul>
  </li>
</ol>
</div>
<div class="vspace_small"></div>

Each layer was clipped with the shape of mainland Portugal for the analysis. 
<div class="vspace_small"></div>

### Temperature

```{r temperature_original, fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, fig.cap="Temperature (°C) in Portugal for January 2020."}
ggplot() +
  geom_spatraster(data = data_prep_env$temperature_pt$t2m_1)   +
  scale_fill_gradient(name = "Temperature (°C)", 
                      low = "blue", high = "red", na.value = "white") +  # 
   theme_simple()
```  



### Evapotranspiration
```{r evapotransp_original, fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, fig.cap="Evapotranspiration (m) in Portugal for January 2020."}
ggplot() +
  geom_spatraster(data = data_prep_env$evapotransp_pt$e_1)   +
  scale_fill_gradient(name = "Evapotranspiration (m)", 
                      low = "lightgrey", high = "gray10", na.value = "white") +
   theme_simple()
```

### Precipitation
```{r precip_original, fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, fig.cap="Precipitation (m) in Portugal for January 2020."}
ggplot() +
  geom_spatraster(data = data_prep_env$precipitation_pt$tp_1)   +
  scale_fill_gradient(name = "Precipitation (m)", 
                      low = "lightblue", high = "darkblue", na.value = "white") +
  theme_simple()
```

### Landcover
<div class="p">
```{r landcover_original, fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, message=FALSE, warning=FALSE, fig.cap="<span class='caption'>Land cover classes in Portugal in 2020.</span>"}

landcover_pt <- landcover_categories(data_prep_env$landcover_pt, 3)

landcover_classes_exist <- existing_landcover_classes(data_prep_env$landcover_pt, 3)

ggplot() +
  geom_spatraster(data = landcover_pt, mapping = aes(fill = label) )   +
  scale_fill_manual(
    values = landcover_classes_exist$hex,
    na.value = "white")+
   labs(fill = NULL) +
  theme_simple() + 
   theme(legend.position = "bottom",
         legend.text = element_text(size = 6))
```

The  label and color information was extracted from the metadata of the land cover layer. However, I decided to change the color for the three cropland rainfed classes 
slightly, so they could be distinguished better.
</div>
<div class="vspace_small"></div>

### Soil
```{r soil_original, fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, fig.cap="Soil organic carbon content (t/ha) in Portugal."}

ggplot() +
  geom_spatraster(data = data_prep_env$SOC_pt)   +
 scale_fill_gradientn(name = "Soil organic carbon (t/ha)",
                      colors = c("#4c0073", "#2a895a", "#ffffbe",
                                  na.value = "white"))+
   theme_simple()
```


<div class="vspace_small"></div>



# Data integration

## Investigating spatial dimensions
I compared the resolution and extent of all layers, to allow for joint analysis of the layers. 
<div class="vspace_small"></div>
<div class="p">

<table style="border-collapse: collapse;">
  <tr>
    <th style="padding: 10px; border: 1px solid black;">Layer Name</th>
    <th style="padding: 10px; border: 1px solid black;">Resolution (lon)</th>
    <th style="padding: 10px; border: 1px solid black;">Resolution (lat)</th>
    <th style="padding: 10px; border: 1px solid black;">Origin (lon)</th>
    <th style="padding: 10px; border: 1px solid black;">Origin (lat)</th>
  </tr>
  <tr>
    <td style="padding: 5px; border: 1px solid black;">Climate variables</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(res(data_prep_env$evapotransp_pt)[1], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(res(data_prep_env$evapotransp_pt)[2], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(ext(data_prep_env$evapotransp_pt)[1], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(ext(data_prep_env$evapotransp_pt)[3], 4)`</td>
  </tr>
  <tr>
    <td style="padding: 5px; border: 1px solid black;">Land Cover</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(res(data_prep_env$landcover_pt)[1], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(res(data_prep_env$landcover_pt)[2], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(ext(data_prep_env$landcover_pt)[1], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(ext(data_prep_env$landcover_pt)[3], 4)`</td>
  </tr>
  <tr>
    <td style="padding: 5px; border: 1px solid black;">Soil Organic Carbon</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(res(data_prep_env$SOC_pt)[1], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(res(data_prep_env$SOC_pt)[2], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(ext(data_prep_env$SOC_pt)[1], 4)`</td>
    <td style="padding: 5px; border: 1px solid black;">`r round(ext(data_prep_env$SOC_pt)[3], 4)`</td>
  </tr>
</table>

</div>

<div class="vspace_small"></div>
The climate variables (which share the same spatial dimensions) are at a lower resolution than the land cover and SOC layer and also have different origins. Therefore I resampled the latter to the same resolution, origin and extent as the climate variables. 

```{r load_data_integration, include = FALSE}
# Load results of data integration -----------------------------------------
data_integrate_env<- env()
source(here("src/analysis/2_integrate_data.R"), local = data_integrate_env, encoding = "UTF-8")
```

## Data resampling {.tabset}
### Land cover data integration
<div class="p">
Land cover is a categorical variable. I explored two options to resample this data. First using the method "nearest neighbor", which is typically used for categorical variables,as it assigns new pixel values by selecting the nearest original pixel value without any interpolation, effectively copying the closest value to the new pixel location. However, when resampling to a lower resolution it might be more interesting using the class which most high resolution pixels have within the lower resolution. I tested that option as well and compared the maps visually in terms of pattern. 
```{r resample_code_lc, eval = FALSE}
# resample option 1 using nearest neighbor
landcover_pt_near <- terra::resample(landcover_pt, resample_raster, method = "near")

# resample option 2 using majority
landcover_pt_majority <- 
  exactextractr::exact_resample(landcover_pt, 
                                resample_raster, 
                                'majority')
```



```{r landcover_resample,  fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, message=FALSE, warning=FALSE, fig.cap="<span class='caption'>Land cover classes in Portugal in 2020 resampled to climate data with two different methods.</span>"}
# define the categorical landcover classes for the plots
landcover_pt_near <- landcover_categories(data_integrate_env$landcover_pt_near , 3)
landcover_classes_near_exist <- existing_landcover_classes(landcover_pt_near, 3)

landcover_pt_major <- landcover_categories(data_integrate_env$landcover_pt_majority, 3)
landcover_classes_major_exist <- existing_landcover_classes(landcover_pt_major , 3)

plot1 <- ggplot() +
  geom_spatraster(data = landcover_pt_near, mapping = aes(fill = label) )   +
  scale_fill_manual(
    values = landcover_classes_near_exist$hex,
    na.value = "white")+
   labs(fill = NULL) +
  ggtitle(expression(paste("Land cover reprojected with method ", '"near"')))+
  theme_simple()+ 
   theme(legend.position = "none")

plot2 <- ggplot() +
  geom_spatraster(data = landcover_pt_major, mapping = aes(fill = label) )   +
  scale_fill_manual(
    values = landcover_classes_major_exist$hex,
    na.value = "white")+
   labs(fill = NULL) +
   ggtitle(expression(paste("Land cover reprojected with method ", '"majority"')))+
  theme_simple() + 
   theme(legend.position = "none")
  

# Combine plots into a grid arrangement
grid.arrange(plot1, plot2, ncol = 2)
```

When resampling with method "near" the landcover classes are very patchy and fragmented. The layer resampled with majority has more continuous representation of classes and the logic of that resampling method is more sound, so I am using that layer for the analysis.

</div>
<div class="vspace_small"></div>


### Soil organic carbon data integration
Soil organic carbon (SOC) is a continous variable. I want to work with the mean SOC per lower resolution cell. Typically continuous rasters are resampled using method bilinear, which calculates values of a grid location based on nearby grid cells, using a weighted average of the four nearest cell centers.  I tested this option, as well as using an average function within the `exact_resample()` function used for land cover. This function aggregates cells before resampling, so that the average is not based on four grid-cells but all grid cells covered by the lower resolution cell. I compared the maps visually in terms of pattern. 
```{r resample_code_soil, eval = FALSE}
# resample option 1
SOC_pt_bil <- resample(landcover_pt, resample_raster, method = "bilinear")

# resample option 2
SOC_pt_mean <- exactextractr::exact_resample(SOC_pt, 
                                             resample_raster, 
                                             'mean')
```

```{r soil_resample,  fig.asp = 0.8, fig.width = 10, echo = FALSE, return = FALSE, message=FALSE, warning=FALSE, fig.cap="<span class='caption'>Soil organic carbon layer in Portugal resampled with two different methods.</span>"}
plot1 <- ggplot() +
  geom_spatraster(data = data_prep_env$SOC_pt)   +
 scale_fill_gradientn(name = "Soil organic carbon (t/ha)",
                      colors = c("#4c0073", "#2a895a", "#ffffbe",
                                  na.value = "white"))+
    ggtitle(expression(paste("Original SOC layer")))+
   theme_simple()

plot2 <- ggplot() +
  geom_spatraster(data = data_integrate_env$SOC_pt_bil)   +
  scale_fill_gradientn(name = "Soil organic carbon (t/ha)",
                       colors = c("#4c0073", "#2a895a", "#ffffbe",
                                  na.value = "white"),
                       limits = c(minmax(data_prep_env$SOC_pt)[1],
                                             minmax(data_prep_env$SOC_pt)[2]))+
  ggtitle(expression(paste("SOC reprojected with method ", '"bilinear"')))+
   theme_simple()

plot3 <- ggplot() +
  geom_spatraster(data = data_integrate_env$SOC_pt_mean)   +
  scale_fill_gradientn(name = "Soil organic carbon (t/ha)",
                       colors = c("#4c0073", "#2a895a", "#ffffbe",
                                  na.value = "white"),
                             limits = c(minmax(data_prep_env$SOC_pt)[1],
                                             minmax(data_prep_env$SOC_pt)[2]))+
  ggtitle(expression(paste("SOC reprojected with method ", '"mean"')))+
   theme_simple()


# Combine plots into a grid arrangement
grid.arrange(plot1, arrangeGrob(plot2, plot3, ncol = 2), ncol = 1)
```
When resampling with method ´exact_resample´ and function "mean" the pattern of low SOC values along the cost and high values in the North of Portugal is maintained, therefore I am going to use that layer for the analysis. 

</div>
<div class="vspace_small"></div>


# Analysis and Visualization

I can then check whether the dimensions for all layers match before proceeding with the analysis using the ´compareGeom()´ function.
```{r code_compareGEOM, eval = FALSE}
compareGeom(evapotransp_pt, precipitation_pt, temperature_pt,
            landcover_pt, SOC_pt)
```

# Sampling scheme


# Soil model


